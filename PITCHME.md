# Python для сетевых инженеров 

---
## Welcome to продленка :)

---

## Генераторы

+++
### Генератор (generator)

Генератор - функция, которая позволяет легко создавать свои итераторы

В отличии от обычных функций, генератор не просто возвращает значение и завершает работу, а возвращает итератор, который отдает элементы по одному.

Функция-генератор - это функция, в которой присутствует ключевое слово yield.
При вызове, эта функция возвращает объект генератор. 

+++
### Функции

Обычная функция завершает работу если:
* встретилось выражение return
* закончился код функции (это срабатывает как выражение ```return None```)
* возникло исключение

После выполнения функции, управление возвращается и программа выполняется дальше.
Все аргументы, которые передавались в функцию, локальные переменные, все это теряется.
Остается только результат, который вернула функция.

Функция может возвращать список элементов, несколько объектов или возвращать разные результаты, в зависимости от аргументов, но она всегда возвращает какой-то один результат.

+++
### Генератор (generator)

С точки зрения синтаксиса, генератор выглядит как обычная функция.
Но, вместо return, используется оператор ```yield```.

Каждый раз, когда внутри функции встречается yield, генератор приостанавливается и возвращает значение.
При следующем запросе, генератор начинает работать с того же места, где он завершил работу в прошлый раз.

Так как yield не завершает работу генератора, он может использоваться несколько раз.

---
### Пример генератора

Пример функции-генератора:
```python
In [1]: def generate_nums(number):
   ...:     print('Start of generation')
   ...:     yield number
   ...:     print('Next number')
   ...:     yield number+1
   ...:     print('The end')
   ...:
```


+++
### Пример генератора

Если вызвать функцию-генератор и присвоить результат в переменную, его код еще не будет выполняться:
```python
In [3]: result = generate_nums(100)
```

Теперь в переменной result находится итератор:
```python
In [4]: result
Out[4]: <generator object generate_nums at 0xb5788e9c>
```

+++
### Пример генератора

Раз result это итератор, можно вызвать функцию next, чтобы получить значение:
```python
In [5]: next(result)
Start of generation
Out[5]: 100
```

Второй вызов next:
```python
In [6]: next(result)
Next number
Out[6]: 101
```

+++
### Пример генератора


Следующий next:
```python
In [7]: next(result)
The end
------------------------------------------------------------
StopIteration              Traceback (most recent call last)
<ipython-input-7-1b214ba10814> in <module>()
----> 1 next(result)

StopIteration:
```

+++
### Пример генератора

Раз функция-генератор возвращает итератор, его можно использовать в цикле:
```python
In [8]: for num in generate_nums(100):
   ...:     print('Number:', num)
   ...:
Start of generation
Number: 100
Next number
Number: 101
The end
```

---
### Обычная функция и аналогичный генератор

С помощью генераторов зачастую можно написать ту же функцию с меньшим количеством промежуточных переменных.
```python
In [14]: def work_with_items(items):
    ...:     result = []
    ...:     for item in items:
    ...:         result.append('Changed {}'.format(item))
    ...:     return result
    ...:

In [15]: for i in work_with_items(range(10)):
    ...:     print(i)
    ...:
Changed 0
Changed 1
Changed 2
Changed 3
Changed 4
Changed 5
Changed 6
Changed 7
Changed 8
Changed 9
```

+++
### Обычная функция и аналогичный генератор

Можно заменить таким генератором:
```python
In [16]: def yield_items(items):
    ...:     for item in items:
    ...:         yield 'Changed {}'.format(item)
    ...:

In [17]: for i in yield_items(range(10)):
    ...:     print(i)
    ...:
Changed 0
Changed 1
Changed 2
Changed 3
Changed 4
Changed 5
Changed 6
Changed 7
Changed 8
Changed 9
```

+++
### Обычная функция и аналогичный генератор

Генератор yield_items возвращает элементы по одному, а функция work_with_items - собирает их в список, а потом возвращает.
Если количество элементов небольшое, это не существенно, но, при обработке больших объемов данных, лучше работать с элементами по одному.

+++
### Обычная функция и аналогичный генератор

В любой момент, если действительно нужно получить все элементы, например, в виде списка, это можно сделать применив функцию list:
```python
In [20]: result =  yield_items(range(10))

In [21]: result
Out[21]: <generator object yield_items at 0xb579053c>

In [22]: list(result)
Out[22]:
['Changed 0',
 'Changed 1',
 'Changed 2',
 'Changed 3',
 'Changed 4',
 'Changed 5',
 'Changed 6',
 'Changed 7',
 'Changed 8',
 'Changed 9']
```

---
### Использование генератора, при работе с файлами

Например, при обработке большого log-файла, лучше обрабатывать его построчно, не выгружая все содержимое в память.

Допустим, нам нужно часто фильтровать определенные строки из файла.
Например, надо получить только строки, которые соответствуют регулярному выражению.
Конечно, можно каждый раз это делать в процессе обработки строк.
Но можно вынести подобную функциональность и в отдельную функцию.

Но только, в случае обычной функции, придется опять возвращать список или подобный объект.
А, если файл очень большой, то, скорее всего, придется отказаться от этой затеи.

+++
### Использование генератора, при работе с файлами

Однако, если использовать генератор, файл будет обрабатываться построчно.
Это может быть, например, такой генератор:
```python
In [3]: import re

In [5]: def filter_lines(filename, regex):
   ...:     with open(filename) as f:
   ...:         for line in f:
   ...:             if re.search(regex, line):
   ...:                 yield line.rstrip()
   ...:
```

Генератор проходится по указанному файлу и отдает те строки, которые совпали с регулярным выражением.

+++
### Использование генератора, при работе с файлами


Пример использования:
```python
In [7]: for line in filter_lines('config_r1.txt', '^interface'):
   ...:     print(line)
   ...:
interface Loopback0
interface Tunnel0
interface Ethernet0/0
interface Ethernet0/1
interface Ethernet0/2
interface Ethernet0/3
interface Ethernet0/3.100
interface Ethernet1/0
```

---
## generator expression (генераторное выражение)

+++
### generator expression (генераторное выражение)

Генераторное выражение использует такой же синтаксис, как list comprehentions, но возвращает итератор, а не список.

Генераторное выражение выглядит точно так же, как list comprehentions, но используются круглые скобки:
```python
In [1]: genexpr = (x**2 for x in range(10000))

In [2]: genexpr
Out[2]: <generator object <genexpr> at 0xb571ec8c>

In [3]: next(genexpr)
Out[3]: 0

In [4]: next(genexpr)
Out[4]: 1

In [5]: next(genexpr)
Out[5]: 4
```


